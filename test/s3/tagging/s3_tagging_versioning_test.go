package tagging
package tagging

import (
	"context"
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)












































































































































































































































































































































































































































}	assert.Len(t, tagResp2.TagSet, 1, "Version 2 should have 1 tag")	require.NoError(t, err)	})		VersionId: aws.String(versionId2),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp2, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	assert.Len(t, tagResp1.TagSet, 2, "Version 1 should have 2 tags after modification")	require.NoError(t, err)	})		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp1, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Verify final state	require.NoError(t, err)	})		},			},				},					Value: aws.String("current"),					Key:   aws.String("status"),				{			TagSet: []types.Tag{		Tagging: &types.Tagging{		VersionId: aws.String(versionId2),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	_, err = client.PutObjectTagging(context.TODO(), &s3.PutObjectTaggingInput{	// Add tags to version 2	require.NoError(t, err)	})		},			},				},					Value: aws.String("2024-01-01"),					Key:   aws.String("archived-date"),				{				},					Value: aws.String("archived"),					Key:   aws.String("status"),				{			TagSet: []types.Tag{		Tagging: &types.Tagging{		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	_, err = client.PutObjectTagging(context.TODO(), &s3.PutObjectTaggingInput{	// Modify tags on version 1 (replace status and add new tag)	require.NoError(t, err)	})		},			},				},					Value: aws.String("old"),					Key:   aws.String("status"),				{			TagSet: []types.Tag{		Tagging: &types.Tagging{		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	_, err = client.PutObjectTagging(context.TODO(), &s3.PutObjectTaggingInput{	// Add tags to version 1	versionId2 := *version2Resp.VersionId	require.NoError(t, err)	})		Body:   strings.NewReader("Version 2"),		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	version2Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Create version 2	time.Sleep(50 * time.Millisecond)	versionId1 := *version1Resp.VersionId	require.NoError(t, err)	})		Body:   strings.NewReader("Version 1"),		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	version1Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Create version 1	objectKey := "versioned-modify-tags"	defer cleanupTestBucket(t, client, bucketName)	bucketName := createVersionedTestBucket(t, client)	client := getS3Client(t)func TestModifyTagsOnVersionedObject(t *testing.T) {// TestModifyTagsOnVersionedObject tests changing tags on different versions independently}	assert.Equal(t, "prod", tagMapLatest["stage"], "Latest version should have stage=prod")	assert.Equal(t, "2", tagMapLatest["v"], "Latest version should have v=2")	}		tagMapLatest[*tag.Key] = *tag.Value	for _, tag := range tagRespLatest.TagSet {	tagMapLatest := make(map[string]string)	assert.Len(t, tagRespLatest.TagSet, 2, "Latest version should have 2 tags")	require.NoError(t, err, "Should be able to get tags from latest version")	})		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	tagRespLatest, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Get tags from latest version (should be version 2)	assert.Equal(t, "prod", tagMap2["stage"], "Version 2 should have stage=prod")	assert.Equal(t, "2", tagMap2["v"], "Version 2 should have v=2")	}		tagMap2[*tag.Key] = *tag.Value	for _, tag := range tagResp2.TagSet {	tagMap2 := make(map[string]string)	assert.Len(t, tagResp2.TagSet, 2, "Version 2 should have 2 tags")	require.NoError(t, err, "Should be able to get tags from version 2")	})		VersionId: aws.String(versionId2),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp2, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	assert.Equal(t, "dev", tagMap1["stage"], "Version 1 should have stage=dev")	assert.Equal(t, "1", tagMap1["v"], "Version 1 should have v=1")	}		tagMap1[*tag.Key] = *tag.Value	for _, tag := range tagResp1.TagSet {	tagMap1 := make(map[string]string)	assert.Len(t, tagResp1.TagSet, 2, "Version 1 should have 2 tags")	require.NoError(t, err, "Should be able to get tags from version 1")	})		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp1, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Get tags from specific versions	versionId2 := *version2Resp.VersionId	require.NoError(t, err)	})		Tagging: aws.String("v=2&stage=prod"),		Body:    strings.NewReader("Version 2"),		Key:    aws.String(objectKey),		Bucket:  aws.String(bucketName),	version2Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	time.Sleep(50 * time.Millisecond)	versionId1 := *version1Resp.VersionId	require.NoError(t, err)	})		Tagging: aws.String("v=1&stage=dev"),		Body:    strings.NewReader("Version 1"),		Key:     aws.String(objectKey),		Bucket:  aws.String(bucketName),	version1Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Create multiple versions	objectKey := "versioned-object-get-tags"	defer cleanupTestBucket(t, client, bucketName)	bucketName := createVersionedTestBucket(t, client)	client := getS3Client(t)func TestGetObjectTaggingOnVersionedBucket(t *testing.T) {// TestGetObjectTaggingOnVersionedBucket tests retrieving tags from versioned objects}	assert.Len(t, tagResp2.TagSet, 2, "Version 2 should still have 2 tags")	require.NoError(t, err)	})		VersionId: aws.String(versionId2),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp2, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Verify version 2 still has tags	assert.Len(t, tagResp1.TagSet, 0, "Version 1 should have 0 tags after deletion")	require.NoError(t, err)	})		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp1, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Verify version 1 has no tags	require.NoError(t, err, "Should be able to delete tags from version 1")	})		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	_, err = client.DeleteObjectTagging(context.TODO(), &s3.DeleteObjectTaggingInput{	// Delete tags from version 1 only	versionId2 := *version2Resp.VersionId	require.NoError(t, err)	})		Tagging: aws.String("version=v2&keep=true"),		Body:    strings.NewReader("Version 2"),		Key:     aws.String(objectKey),		Bucket:  aws.String(bucketName),	version2Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	time.Sleep(50 * time.Millisecond)	versionId1 := *version1Resp.VersionId	require.NoError(t, err)	})		Tagging: aws.String("version=v1&keep=true"),		Body:    strings.NewReader("Version 1"),		Key:     aws.String(objectKey),		Bucket:  aws.String(bucketName),	version1Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Create two versions with tags	objectKey := "versioned-multi-delete-tags"	defer cleanupTestBucket(t, client, bucketName)	bucketName := createVersionedTestBucket(t, client)	client := getS3Client(t)func TestDeleteObjectTaggingOnSpecificVersionInVersionedBucket(t *testing.T) {// TestDeleteObjectTaggingOnSpecificVersionInVersionedBucket tests deleting tags on a specific version}	assert.Len(t, tagResp.TagSet, 0, "Should have 0 tags after deletion")	require.NoError(t, err)	})		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	tagResp, err = client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Verify tags are deleted	require.NoError(t, err, "Should be able to delete tags from versioned object")	})		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	_, err = client.DeleteObjectTagging(context.TODO(), &s3.DeleteObjectTaggingInput{	// Delete tags from the versioned object	assert.Len(t, tagResp.TagSet, 2, "Should have 2 tags before deletion")	require.NoError(t, err)	})		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	tagResp, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Verify tags exist	versionId := *putResp.VersionId	require.NoError(t, err)	})		Tagging: aws.String("env=dev&purpose=testing"),		Body:    strings.NewReader(objectContent),		Key:     aws.String(objectKey),		Bucket:  aws.String(bucketName),	putResp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Put object with tags in versioned bucket	objectContent := "Hello, Delete Tags!"	objectKey := "versioned-object-tag-delete"	defer cleanupTestBucket(t, client, bucketName)	bucketName := createVersionedTestBucket(t, client)	client := getS3Client(t)func TestDeleteObjectTaggingOnVersionedBucket(t *testing.T) {// TestDeleteObjectTaggingOnVersionedBucket tests deleting tags from versioned objects}	assert.Equal(t, "v2", *tagResp2.TagSet[0].Value, "Version 2 tag value should be 'v2'")	assert.Len(t, tagResp2.TagSet, 1, "Version 2 should have 1 tag")	require.NoError(t, err, "Should be able to get tags from version 2")	})		VersionId: aws.String(versionId2),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp2, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Get tags from version 2	assert.Equal(t, "v1", *tagResp1.TagSet[0].Value, "Version 1 tag value should be 'v1'")	assert.Len(t, tagResp1.TagSet, 1, "Version 1 should have 1 tag")	require.NoError(t, err, "Should be able to get tags from version 1")	})		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	tagResp1, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Get tags from version 1	require.NoError(t, err, "Should be able to put tags on specific version 2")	})		},			},				},					Value: aws.String("v2"),					Key:   aws.String("version"),				{			TagSet: []types.Tag{		Tagging: &types.Tagging{		VersionId: aws.String(versionId2),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	_, err = client.PutObjectTagging(context.TODO(), &s3.PutObjectTaggingInput{	// Set tags on version 2	require.NoError(t, err, "Should be able to put tags on specific version 1")	})		},			},				},					Value: aws.String("v1"),					Key:   aws.String("version"),				{			TagSet: []types.Tag{		Tagging: &types.Tagging{		VersionId: aws.String(versionId1),		Key:       aws.String(objectKey),		Bucket:    aws.String(bucketName),	_, err = client.PutObjectTagging(context.TODO(), &s3.PutObjectTaggingInput{	// Set tags on version 1	versionId2 := *version2Resp.VersionId	require.NoError(t, err)	})		Body:   strings.NewReader("Version 2"),		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	version2Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	time.Sleep(50 * time.Millisecond)	// Small delay to ensure different version IDs	versionId1 := *version1Resp.VersionId	require.NoError(t, err)	})		Body:   strings.NewReader("Version 1"),		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	version1Resp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Create multiple versions of the object	objectKey := "multi-version-object"	defer cleanupTestBucket(t, client, bucketName)	bucketName := createVersionedTestBucket(t, client)	client := getS3Client(t)func TestPutObjectTaggingOnSpecificVersionInVersionedBucket(t *testing.T) {// TestPutObjectTaggingOnSpecificVersionInVersionedBucket tests setting tags on a specific version}	assert.Equal(t, "platform", tagMap["team"], "team tag should be 'platform'")	assert.Equal(t, "production", tagMap["env"], "env tag should be 'production'")	}		tagMap[*tag.Key] = *tag.Value	for _, tag := range tagResp.TagSet {	tagMap := make(map[string]string)	assert.Len(t, tagResp.TagSet, 2, "Should have 2 tags")	// Verify tags	require.NoError(t, err, "Should be able to get tags from versioned object")	})		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	tagResp, err := client.GetObjectTagging(context.TODO(), &s3.GetObjectTaggingInput{	// Get the tags back	require.NoError(t, err, "Should be able to put tags on versioned object")	})		},			},				},					Value: aws.String("platform"),					Key:   aws.String("team"),				{				},					Value: aws.String("production"),					Key:   aws.String("env"),				{			TagSet: []types.Tag{		Tagging: &types.Tagging{		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	_, err = client.PutObjectTagging(context.TODO(), &s3.PutObjectTaggingInput{	// Set tags on the object in versioned bucket	versionId := *putResp.VersionId	require.NoError(t, err, "Should be able to put object in versioned bucket")	})		Body:   strings.NewReader(objectContent),		Key:    aws.String(objectKey),		Bucket: aws.String(bucketName),	putResp, err := client.PutObject(context.TODO(), &s3.PutObjectInput{	// Put object in versioned bucket	objectContent := "Hello, Versioned World!"	objectKey := "versioned-object-with-tags"	defer cleanupTestBucket(t, client, bucketName)	bucketName := createVersionedTestBucket(t, client)	client := getS3Client(t)func TestPutObjectTaggingOnVersionedBucket(t *testing.T) {// This is the fix for GitHub issue #7868 where tagging failed with "no entry is found in filer store"// TestPutObjectTaggingOnVersionedBucket tests setting tags on objects in a versioned bucket}	return bucketName	time.Sleep(100 * time.Millisecond)	// Wait for versioning configuration to be applied	require.NoError(t, err, "Should be able to enable versioning")	})		},			Status: types.BucketVersioningStatusEnabled,		VersioningConfiguration: &types.VersioningConfiguration{		Bucket: aws.String(bucketName),	_, err := client.PutBucketVersioning(context.TODO(), &s3.PutBucketVersioningInput{	// Enable versioning on the bucket	bucketName := createTestBucket(t, client)func createVersionedTestBucket(t *testing.T, client *s3.Client) string {// createVersionedTestBucket creates a test bucket with versioning enabled