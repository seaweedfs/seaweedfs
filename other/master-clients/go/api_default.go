/*
Seaweedfs Master Server API

The Seaweedfs Master Server API allows you to store blobs

API version: 3.43.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiDirAssignRequest struct {
	ctx                 context.Context
	ApiService          *DefaultApiService
	count               *interface{}
	collection          *interface{}
	dataCenter          *interface{}
	rack                *interface{}
	dataNode            *interface{}
	disk                *interface{}
	replication         *interface{}
	ttl                 *interface{}
	preallocate         *interface{}
	memoryMapMaxSizeMb  *interface{}
	writableVolumeCount *interface{}
}

// how many file ids to assign. Use &lt;fid&gt;_1, &lt;fid&gt;_2 for the assigned additional file ids. e.g. 3,01637037d6_1, 3,01637037d6_2
func (r ApiDirAssignRequest) Count(count interface{}) ApiDirAssignRequest {
	r.count = &count
	return r
}

// required collection name
func (r ApiDirAssignRequest) Collection(collection interface{}) ApiDirAssignRequest {
	r.collection = &collection
	return r
}

// preferred data center
func (r ApiDirAssignRequest) DataCenter(dataCenter interface{}) ApiDirAssignRequest {
	r.dataCenter = &dataCenter
	return r
}

// preferred rack
func (r ApiDirAssignRequest) Rack(rack interface{}) ApiDirAssignRequest {
	r.rack = &rack
	return r
}

// preferred volume server, e.g. 127.0.0.1:8080
func (r ApiDirAssignRequest) DataNode(dataNode interface{}) ApiDirAssignRequest {
	r.dataNode = &dataNode
	return r
}

// If you have disks labelled, this must be supplied to specify the disk type to allocate on.
func (r ApiDirAssignRequest) Disk(disk interface{}) ApiDirAssignRequest {
	r.disk = &disk
	return r
}

// replica placement strategy
func (r ApiDirAssignRequest) Replication(replication interface{}) ApiDirAssignRequest {
	r.replication = &replication
	return r
}

// file expiration time limit, example: 3m for 3 minutes. units: m-minute, h-hour, d-day, w-week, M-month, y-year
func (r ApiDirAssignRequest) Ttl(ttl interface{}) ApiDirAssignRequest {
	r.ttl = &ttl
	return r
}

// If no matching volumes, pre-allocate this number of bytes on disk for new volumes.
func (r ApiDirAssignRequest) Preallocate(preallocate interface{}) ApiDirAssignRequest {
	r.preallocate = &preallocate
	return r
}

// Only implemented for windows. Use memory mapped files with specified size for new volumes.
func (r ApiDirAssignRequest) MemoryMapMaxSizeMb(memoryMapMaxSizeMb interface{}) ApiDirAssignRequest {
	r.memoryMapMaxSizeMb = &memoryMapMaxSizeMb
	return r
}

// If no matching volumes, create specified number of new volumes.
func (r ApiDirAssignRequest) WritableVolumeCount(writableVolumeCount interface{}) ApiDirAssignRequest {
	r.writableVolumeCount = &writableVolumeCount
	return r
}

func (r ApiDirAssignRequest) Execute() (*FileKey, *http.Response, error) {
	return r.ApiService.DirAssignExecute(r)
}

/*
DirAssign Assign a file key

This operation is very cheap. Just increase a number in master server's memory.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDirAssignRequest
*/
func (a *DefaultApiService) DirAssign(ctx context.Context) ApiDirAssignRequest {
	return ApiDirAssignRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FileKey
func (a *DefaultApiService) DirAssignExecute(r ApiDirAssignRequest) (*FileKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FileKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DirAssign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dir/assign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.collection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collection", r.collection, "")
	}
	if r.dataCenter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataCenter", r.dataCenter, "")
	}
	if r.rack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack", r.rack, "")
	}
	if r.dataNode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataNode", r.dataNode, "")
	}
	if r.disk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disk", r.disk, "")
	}
	if r.replication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replication", r.replication, "")
	}
	if r.ttl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ttl", r.ttl, "")
	}
	if r.preallocate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preallocate", r.preallocate, "")
	}
	if r.memoryMapMaxSizeMb != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memoryMapMaxSizeMb", r.memoryMapMaxSizeMb, "")
	}
	if r.writableVolumeCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "writableVolumeCount", r.writableVolumeCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDirLookupRequest struct {
	ctx        context.Context
	ApiService *DefaultApiService
	volumeId   *interface{}
	collection *interface{}
	fileId     *interface{}
	read       *interface{}
}

// volume id
func (r ApiDirLookupRequest) VolumeId(volumeId interface{}) ApiDirLookupRequest {
	r.volumeId = &volumeId
	return r
}

// optionally to speed up the lookup
func (r ApiDirLookupRequest) Collection(collection interface{}) ApiDirLookupRequest {
	r.collection = &collection
	return r
}

// If provided, this returns the fileId location and a JWT to update or delete the file.
func (r ApiDirLookupRequest) FileId(fileId interface{}) ApiDirLookupRequest {
	r.fileId = &fileId
	return r
}

// works together with \&quot;fileId\&quot;, if read&#x3D;yes, JWT is generated for reads.
func (r ApiDirLookupRequest) Read(read interface{}) ApiDirLookupRequest {
	r.read = &read
	return r
}

func (r ApiDirLookupRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DirLookupExecute(r)
}

/*
DirLookup Lookup volume

We would need to find out whether the volumes have moved.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDirLookupRequest
*/
func (a *DefaultApiService) DirLookup(ctx context.Context) ApiDirLookupRequest {
	return ApiDirLookupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *DefaultApiService) DirLookupExecute(r ApiDirLookupRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DirLookup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dir/lookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.volumeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "volumeId", r.volumeId, "")
	}
	if r.collection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collection", r.collection, "")
	}
	if r.fileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileId", r.fileId, "")
	}
	if r.read != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "read", r.read, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
